// solution to question 1
class Solution {
public:
    int findDuplicate(vector<int>& nums) {
        int i=0,n=nums.size();
        while(i<n)
        {
            if (nums[i] == -1)return i;
            int cur = i;
            
            i = nums[i] ;
            
            nums[cur] = -1;
            
        }
        return 0;
    }
};

// solution2
class Solution {
public:
    vector<int> findDuplicates(vector<int>& nums) {
        vector<int> ans;
        for(int i=0,n=nums.size();i<n;i++)
        {
            int num = abs(nums[i]) -1 ;
            if(nums[num]<0){
                ans.push_back(num+1);
            }
            nums[num]*=-1;
        }
        
        
        return ans;
    }
};


// Solution for 0 1 2 sorting
class Solution {
public:
    void sortColors(vector<int>& nums) {
       int n = nums.size(),second=n-1, zero=0;
            for (int i=0; i<=second; i++) {
                while (nums[i]==2 && i<second) swap(nums[i], nums[second--]);
                while (nums[i]==0 && i>zero) swap(nums[i], nums[zero++]);
            }
    }
};

class Solution {
public:
    void sortColors(vector<int>& nums) {
        int i=0,r,b,w,wc=0,bc=0,n = nums.size(),temp;
        
        for(i=0;i<n;i++)
        {
            if(nums[i] == 0)++wc;
            else if(nums[i] == 1) ++bc;
        }
        
        bc+=wc;
        r=0;
        w=wc;
        b = bc;
        
        for(i=0;i<n;)
        {
            if(nums[i] == 0 && i>=wc)
            {
                temp = nums[i];
                nums[i] = nums[r];
                nums[r] = temp;
                ++r;
            }
            else if(nums[i] ==1 && (i<wc || i>=bc))
            {
                temp = nums[i];
                nums[i] = nums[w];
                nums[w] = temp;
                ++w;
            }
            else if(nums[i] == 2 && i<bc)
            {
                temp = nums[i];
                nums[i] = nums[b];
                nums[b] = temp;
                ++b;
            }
            else{
                i++;
            }
        }
        
    }
};

// Find missing number 
class Solution {
public:
    int missingNumber(vector<int>& nums) {
        int n=nums.size(),sumshouldbe = n*(n+1)/2,sum=0;
        for(int i=0;i<n;i++)sum+=nums[i];
        return sumshouldbe - sum;
        
    }
};


// merge the sorted arrays
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        int i=m-1;
		int j=n-1;
		int k = m+n-1;
		while(i >=0 && j>=0)
		{
			if(nums1[i] > nums2[j])
				nums1[k--] = nums1[i--];
			else
				nums1[k--] = nums2[j--];
		}
		while(j>=0)
			nums1[k--] = nums2[j--];
    }
        
    
};

// MAX subarray
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int i,n=nums.size(), sum=0,maxsum=INT_MIN;
        for(i=0;i<n;++i)
        {
            sum+=nums[i];
            if(sum>maxsum){
                maxsum=sum;
            }
            if(sum<0)sum=0;
        }
        return maxsum;
    }
};

// Merge overlapping intervals
class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        vector<vector<int>> res;
        int i,n=intervals.size();
        if(n==0)return res;
        sort(intervals.begin(),intervals.end());
        vector<int> overlap;
        overlap.push_back(intervals[0][0]);
        int r = intervals[0][1];
        for(i=1;i<n;i++)
        {
            if(intervals[i][0]<=r)
            {
                r = max(r,intervals[i][1]);
            }else{
                overlap.push_back(r);
                res.push_back(overlap);
                overlap.clear();
                overlap.push_back(intervals[i][0]);
                r = intervals[i][1];
            }
            
        }
        overlap.push_back(r);
        res.push_back(overlap);
        return res;
    }
};

